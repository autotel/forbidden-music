const readdir = require('fs').readdirSync;
const writeFile = require('fs').writeFileSync;
const readFileSync = require('fs').readFileSync;
const path = require('path');
const scriptDir = "./"

const samplesRelativetoSrc = 'audio';
const samplesDir = path.join(scriptDir, "/public", samplesRelativetoSrc);
const samplePacks = readdir(samplesDir);



/**
 * make sure that the script is being called from one dir up
 */
if (!samplePacks) {
    throw new Error("run this script from the root of the project");
}

const samplePackIsImpulseResponse = samplePack => samplePack.match(/impulse-responses/i);
const filenameIsReadme = filename => filename.match(/_?readme\.txt$/);
const filenameIsAudioSample = filename => filename.match(/.*\.(wav|aiff)$/);
/**
 * function that maps the array, but if the callback returns false, it will not be included in the result
 */
const filterMap = (arr, callback) => {
    const result = [];
    for (let i = 0; i < arr.length; i++) {
        const item = callback(arr[i], i, arr);
        if (item) {
            result.push(item);
        }
    }
    return result;
}

const impulseResponsesList = filterMap(samplePacks, samplePack => {
    if (!samplePackIsImpulseResponse(samplePack)) return false;
    const files = readdir(path.join(samplesDir, samplePack));
    const readmesList = filterMap(files, sample => {
        if (!filenameIsReadme(sample)) {
            return false;
        }
        const contents = readFileSync(path.join(samplesDir, samplePack, sample), 'utf8');
        return contents;
    });

    return filterMap(files, sample => {
        console.log("isAudio?",sample, filenameIsAudioSample(sample))
        if(!filenameIsAudioSample(sample)) {
            return false;
        }
        const name = sample.replace(/\.(wav)$/, '');
        return {
            name, 
            path: path.join(samplesRelativetoSrc, samplePack, sample),
            collection: samplePack,
            readme: readmesList.join('\n')
        }
    })
});

const samplePacksList = filterMap(samplePacks, samplePack => {
    if (samplePackIsImpulseResponse(samplePack)) return false;
    const files = readdir(path.join(samplesDir, samplePack));

    const readmesList = filterMap(files, sample => {
        if (!filenameIsReadme(sample)) {
            return false;
        }
        const contents = readFileSync(path.join(samplesDir, samplePack, sample), 'utf8');
        return contents;
    });

    const exclusive = files.includes("_exclusive")
    const onlyLocal = files.includes("_only_local")

    const samplesList = filterMap(files, sample => {
        if (!filenameIsAudioSample(sample)) {
            return false;
        }

        const baseName = sample.replace(/\.(wav)$/, '');
        const parts = baseName.split(/[\_]/);
        const frequency = parts.pop();
        const velocity = parts.pop();

        const fq = parseFloat(frequency);

        if (isNaN(fq)) {
            return false
        }

        const returnValue = {
            name: sample,
            frequency: fq,
            path: path.join(samplesRelativetoSrc, samplePack, sample)
        };


        /** @type {boolean | number} */
        let vel = false;
        if (velocity) {
            vel = parseInt(velocity);
            if (isNaN(vel)) {
                vel = false;
            }
            returnValue.velocity = vel / 127;
        }
        console.log("sample", samplePack, sample, { fq, vel });

        return returnValue;

    });
    const isComplexSampler = samplesList.find(sample => sample.frequency <= 0) !== undefined;

    if (samplesList.length === 0) {
        return false;
    }
    return {
        name: samplePack,
        isComplexSampler,
        exclusive,
        onlyLocal,
        samples: samplesList,
        readme: readmesList.join('\n'),
    };
});

writeFile(
    path.join(scriptDir, './src', '_autogenerated_samples.ts'),
    "export default " + JSON.stringify(samplePacksList, null, 2)
);
writeFile(
    path.join(scriptDir, './src', '_autogenerated_impulse_responses.ts'),
    "export default " + JSON.stringify(impulseResponsesList, null, 2)
);