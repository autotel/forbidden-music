//@ts-check

const fs = require('fs');
const writeFile = require('fs').writeFileSync;
const path = require('path');
const decode = require('wav-decoder').decode;

/**
 * https://gist.github.com/mbitsnbites/a065127577ff89ff885dd0a932ec2477
 * @param {number[]} x_re
 * @param {number[]} x_im
 * */
const fft = (x_re, x_im) => {
    var m = x_re.length / 2, k, X_re = [], X_im = [], Y_re = [], Y_im = [],
        a, b, tw_re, tw_im;

    for (k = 0; k < m; ++k) {
        X_re[k] = x_re[2 * k];
        X_im[k] = x_im[2 * k];
        Y_re[k] = x_re[2 * k + 1];
        Y_im[k] = x_im[2 * k + 1];
    }

    if (m > 1) {
        fft(X_re, X_im);
        fft(Y_re, Y_im);
    }

    for (k = 0; k < m; ++k) {
        a = -Math.PI * k / m, tw_re = Math.cos(a), tw_im = Math.sin(a);
        a = tw_re * Y_re[k] - tw_im * Y_im[k];
        b = tw_re * Y_im[k] + tw_im * Y_re[k];
        x_re[k] = X_re[k] + a;
        x_im[k] = X_im[k] + b;
        x_re[k + m] = X_re[k] - a;
        x_im[k + m] = X_im[k] - b;
    }
}

const containerOfAll = path.resolve('./public/audio')

const samplePacks = fs.readdirSync(containerOfAll);
/**
 * make sure that the script is being called from one dir up
 */
if (!samplePacks) {
    throw new Error("run this script from the root of the project");
}

const promises = [];
const results = [];

samplePacks.forEach(samplePack => {

    const container = path.join(containerOfAll, samplePack)
    const samples = fs.readdirSync(container);
    let doneWithOne = false;

    samples.forEach(file => {
        if(doneWithOne) {
            return false;
        }
        if(!file.match(/[\d\.]+\.wav$/)) {
            return false;
        }

        promises.push(new Promise(async (resolve, reject) => {
            try{
                const filepath = path.join(container, file)
                if(!fs.existsSync(filepath)) {
                    throw new Error("file "+filepath+" does not exist")
                }
                const buffer = fs.readFileSync(filepath)
                if(!buffer.length) {
                    throw new Error("buffer is empty")
                }
                const decoded = await decode(buffer) // get audio data from file using `wav-decoder`
                if(!decoded.channelData) {
                    throw new Error("no channel data")
                }
                const stereo =  Array.from(decoded.channelData) // get a single channel of sound
                const leftChannel = Array.from(stereo[0]).flat()
                
                if(leftChannel[0]==undefined) {
                    throw new Error("no left channel")
                }

                let real = leftChannel;
                let imag = new Array(leftChannel.length).fill(0)

                fft(real,imag)

                real = real.slice(1, 33)
                imag = imag.slice(1, 33)

                // skip this if all the reals are null
                if(real.every(v => v === null)) {
                    console.log("skipping", samplePack, file, "because all reals are null")
                    return resolve(false)
                }

                results.push({
                    samplePack,
                    file,
                    real,
                    imag
                })
                resolve(true)
            } catch(e) {
                console.error("failed analyzing ", samplePack, file, e)
            }
            
        }))

        doneWithOne = true;
    });

});


Promise.all(promises).then(() => {
    console.log("done");
    writeFile(
        path.join('./', './src', '_autogenerated_fft_templates.ts'),
        "export default " + JSON.stringify(results, null, 2)
    );
}).catch(e => {
    console.error(e);
    process.exit(1);
});
