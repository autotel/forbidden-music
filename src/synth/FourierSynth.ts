import { useThrottleFn } from "@vueuse/core";
import ftTemplates from "../_autogenerated_fft_templates";
import { OptionSynthParam, ParamType, SynthParam } from "./interfaces/SynthParam";
import { EventParamsBase, PatcheableSynthVoice, Synth } from "./super/Synth";
import { PatcheableType } from "../dataTypes/PatcheableTrait";
// IDEA: could be stereo
const subharmonics = 4;
const frequencyMultiplier = 1
const defaultPericWaveContents = (): [number[], number[]] => {
    // const { real, imag } = ftTemplates[0];
    // real.forEach((value, index) => {
    //     if (real[index] === null) real[index] = 0;
    //     if (imag[index] === null) imag[index] = 0;
    // })
    // return [real as number[], imag as number[]];
    const harmonics = 16;
    const real = []
    const imaginary = []
    for (let i = 0; i < harmonics; i++) {
        real.push(0);
        imaginary.push(0);
    }
    /*
    lol, I spent so long calculationg transposition correspoinding to subharmonics, 
    and not getting it to work. 
    it turns out that web audio api centers it around the highest value 
    */
    real[subharmonics] = 1;
    return [real, imaginary] as [number[], number[]];
}
const getTemplate = (index: number): [number[], number[]] => {
    const { real, imag } = ftTemplates[index];
    real.forEach((value, index) => {
        if (real[index] === null) real[index] = 0;
        if (imag[index] === null) imag[index] = 0;
    })

    // normalize levels
    const maxLevel = Math.max(...real.map((value) => Math.abs(value || 0)));
    real.forEach((value, index) => {
        if (value === null) {
            real[index] = 0;
        } else {
            real[index] = value / maxLevel;
        }
    })


    return [real as number[], imag as number[]];
}
const templatesList = ftTemplates.map((template, index) => {
    return template.samplePack
})



type SimpleRef<T> = {
    value: T;
}
type NullableRef<T> = {
    value: T | null;
}

class FourierVoice implements PatcheableSynthVoice {
    inUse: boolean = false;
    readonly patcheableType = PatcheableType.AudioVoiceModule;
    name = "Fourier Voice";
    output: any;
    periodicWaveRef: SimpleRef<PeriodicWave>;
    params:SynthParam[] = [];
    scheduleStart: (frequency: number, absoluteStartTime: number, eventParams: EventParamsBase) => FourierVoice;
    scheduleEnd: (absoluteStopTime: number) => FourierVoice;
    stop: () => void;
    enable = () => { }
    disable = () => { }
    constructor(audioContext: AudioContext, periodicWaveRef: SimpleRef<PeriodicWave>) {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        this.output = gainNode;
        oscillator.connect(gainNode);
        oscillator.start();
        this.periodicWaveRef = periodicWaveRef;
        let currentReleaseTimeout: number | null | NodeJS.Timer = null;
        const releaseVoice = () => {
            gainNode.gain.cancelScheduledValues(audioContext.currentTime);
            // firefox has a bit of a hard time with this stuff
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.value = 0;
            this.inUse = false;

        }
        let noteStartedTime = 0;
        this.scheduleStart = (
            frequency: number,
            absoluteStartTime: number,
            { velocity }: EventParamsBase
        ) => {
            this.inUse = true;
            noteStartedTime = absoluteStartTime;
            gainNode.gain.cancelScheduledValues(absoluteStartTime);
            gainNode.gain.setValueAtTime(0, absoluteStartTime);
            gainNode.gain.linearRampToValueAtTime(velocity, absoluteStartTime + 0.01);
            oscillator.frequency.value = frequency * frequencyMultiplier;
            oscillator.setPeriodicWave(this.periodicWaveRef.value);
            oscillator.frequency.setValueAtTime(frequency, absoluteStartTime);
            return this;
        };

        this.scheduleEnd = (
            absoluteStopTime: number
        ) => {
            const duration = absoluteStopTime - noteStartedTime;
            gainNode.gain.linearRampToValueAtTime(0, absoluteStopTime);
            currentReleaseTimeout = setTimeout(() => {
                releaseVoice();
                currentReleaseTimeout = null;
            }, duration * 1000);
            return this;
        }

        this.stop = () => {
            if (currentReleaseTimeout !== null) {
                clearTimeout(currentReleaseTimeout);
                currentReleaseTimeout = null;
            }
            releaseVoice();
        }

    }
}

export class FourierSynth extends Synth {
    periodicWaveRef: NullableRef<PeriodicWave> = {
        value: null
    }
    periodicWaveContents = defaultPericWaveContents();
    enable = () => {
        this.updatePeriodicWave();
        this.isReady = true;
    }
    disable = () => { }
    constructor(
        audioContext: AudioContext
    ) {
        super(
            audioContext,
            () => (new FourierVoice(audioContext, this.periodicWaveRef as SimpleRef<PeriodicWave>))
        );
        this.output.gain.value = 0.1;
        this.periodicWaveRef = {
            value: null
        }
        try {
            this.periodicWaveRef = {
                value: audioContext.createPeriodicWave(
                    new Float32Array(this.periodicWaveContents[0]),
                    new Float32Array(this.periodicWaveContents[1])
                )
            }
        } catch (e) {
            console.warn("error creating periodic wave", e);
        }
        const parent = this;
        this.params = [];

        this.params.push({
            displayName: "template",
            type: ParamType.option,
            options: Object.keys(templatesList).map((displayName, value) => ({ displayName, value })),
            selectedIndex: 0,
            set value(value: number) {
                this.selectedIndex = value;
                const contents = getTemplate(value);
                parent.periodicWaveContents[0] = contents[0];
                parent.periodicWaveContents[1] = contents[1];
                parent.updatePeriodicWave();
            },
            get value() {
                return this.selectedIndex;
            },
            exportable: true,
        } as OptionSynthParam);

        this.params.push({
            displayName: "levels",
            type: ParamType.nArray,
            min: -1,
            max: 1,
            updateFlag: "",
            set value(value: number[]) {
                parent.periodicWaveContents[0] = value;
                parent.updatePeriodicWave();
            },
            get value() {
                return parent.periodicWaveContents[0];
            },
            exportable: true,
        })

        this.params.push({
            displayName: "phases",
            type: ParamType.nArray,
            min: -1,
            max: 1,
            updateFlag: "",
            set value(value: number[]) {
                parent.periodicWaveContents[1] = value;
                parent.updatePeriodicWave();
            },
            get value() {
                return parent.periodicWaveContents[1];
            },
            exportable: true,
        })

        this.params.push({
            displayName: "Level",
            type: ParamType.number,
            min: 0, max: 4,
            get value() {
                if (!parent.output) {
                    console.warn("output node not set");
                    return 1;
                }
                return parent.output.gain.value;
            },
            set value(value: number) {
                if (!parent.output) return;
                parent.output.gain.value = value;
            }
        } as SynthParam);
    }
    updatePeriodicWave = useThrottleFn(() => {
        if (this.periodicWaveRef.value === null) throw new Error("no periodicWave");
        const periodicWaveRef = this.periodicWaveRef as SimpleRef<PeriodicWave>;
        periodicWaveRef.value = this.audioContext.createPeriodicWave(
            new Float32Array(this.periodicWaveContents[0]),
            new Float32Array(this.periodicWaveContents[1])
        );
        this.params.forEach((param) => {
            if ('updateFlag' in param) param.updateFlag = Math.random().toString();
        })
        console.log("periodic wave updated");
    }, 4)
}

interface FourierSynthParamSetter {
    periodicWave: number[][];
}