import { defineStore } from "pinia";
import { ConvolutionReverbEffect } from "../synth/ConvolutionReverbEffect";
import { AutoMaximizerEffect } from "../synth/AutoMaximizerEffect";
import { EffectInstance } from "../synth/SynthInterface";
import { usePlaybackStore } from "./playbackStore";
import { useAudioContextStore } from "./audioContextStore";
import { watch, watchEffect } from "vue";
import sampleDefinitions from "../_autogenerated_impulse_responses";

type admissibleEffectTypes = EffectInstance;

const availableEffectConstructors = [
    ConvolutionReverbEffect, AutoMaximizerEffect
];

export const useEffectsStore = defineStore('playback-effects', () => {
    const audioContextStore = useAudioContextStore();

    const myInput = audioContextStore.audioContext.createGain();
    const outputNode = audioContextStore.audioContext.destination;

    const effectsChain = [] as admissibleEffectTypes[];

    const reconnectChain = () => {
        console.log("reconnect chain", effectsChain);
        myInput.disconnect();
        let lastNode:AudioNode = myInput;
        for (let effect of effectsChain) {
            lastNode.connect(effect.inputNode);
            lastNode = effect.outputNode;
        }
        lastNode.connect(outputNode);
    }
    
    const addEffect = (effect: admissibleEffectTypes) => {
        effectsChain.push(effect);
        effect.enable();
        reconnectChain();
    }

    const removeEffect = (effect: admissibleEffectTypes) => {
        effectsChain.splice(effectsChain.indexOf(effect), 1);
        effect.disable();
        reconnectChain();
    }

    audioContextStore.audioContextPromise.then(() => {
        addEffect(new AutoMaximizerEffect(audioContextStore.audioContext));
        addEffect(new ConvolutionReverbEffect(
            audioContextStore.audioContext, 
            sampleDefinitions.flat()
        ));
    });

    return {
        myInput,
        effectsChain,
        addEffect,
        removeEffect,
    }


});