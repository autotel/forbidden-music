import { defineStore } from "pinia";
import { ConvolutionReverbEffect } from "../synth/ConvolutionReverbEffect";
import { AutoMaximizerEffect } from "../synth/AutoMaximizerEffect";
import { EffectInstance } from "../synth/SynthInterface";
import { usePlaybackStore } from "./playbackStore";
import { useAudioContextStore } from "./audioContextStore";
import { watch, watchEffect } from "vue";
import sampleDefinitions from "../_autogenerated_impulse_responses";
import { useCustomSettingsStore } from "./customSettingsStore";

type admissibleEffectTypes = EffectInstance;

const availableEffectConstructors = [
    ConvolutionReverbEffect, AutoMaximizerEffect
];

export const useEffectsStore = defineStore('playback-effects', () => {
    const audioContextStore = useAudioContextStore();
    const userSettingsStore = useCustomSettingsStore();

    const myInput = audioContextStore.audioContext.createGain();
    const outputNode = audioContextStore.audioContext.destination;
    const effectsChain = [] as admissibleEffectTypes[];

    const reconnectChain = () => {
        myInput.disconnect();
        let lastNode: AudioNode = myInput;
        for (let effect of effectsChain) {
            lastNode.disconnect();
            lastNode.connect(effect.inputNode);
            lastNode = effect.outputNode;
        }
        lastNode.connect(outputNode);
    }

    const addEffect = (effect: admissibleEffectTypes) => {
        effectsChain.push(effect);
        effect.enable();
        reconnectChain();
    }

    const removeEffect = (effect: admissibleEffectTypes) => {
        const indexOfEffect = effectsChain.indexOf(effect);
        if(indexOfEffect === -1) {
            throw new Error("Effect not found in chain");
        }
        effectsChain.splice(indexOfEffect, 1);
        effect.disable();
        reconnectChain();
    }

    const emptyEffectsChain = () => {
        effectsChain.length = 0;
        reconnectChain();
    }

    // stufff to do while fx are experimental and not stored feature


    const activateEffects = () => {
        audioContextStore.audioContextPromise.then(() => {
            if (effectsChain.length === 0) {
                addEffect(new AutoMaximizerEffect(audioContextStore.audioContext));
                addEffect(new ConvolutionReverbEffect(
                    audioContextStore.audioContext,
                    sampleDefinitions.flat()
                ));
            }
        });
    }

    const deactivateEffects = () => {
        emptyEffectsChain();
    }

    watch(() => userSettingsStore.effectsEnabled, (value) => {
        if (value) {
            activateEffects();
        } else {
            deactivateEffects();
        }
        console.log("effects enabled", value, effectsChain);
    });

    if(userSettingsStore.effectsEnabled) {
        activateEffects();
    }


    return {
        myInput,
        effectsChain,
        addEffect,
        removeEffect,
    }


});