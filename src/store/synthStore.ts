
import { defineStore } from 'pinia';
import { ref } from 'vue';
import impulseResponseSampleDefinitions from "../_autogenerated_impulse_responses";
import sampleDefinitions from "../_autogenerated_samples";
import { SynthChain } from '../dataStructures/SynthChain';
import { SynthStack } from '../dataStructures/SynthStack';
import { AutomationPoint } from '../dataTypes/AutomationPoint';
import { Note, getFrequency } from "../dataTypes/Note";
import { PatcheableType } from '../dataTypes/PatcheableTrait';
import { abbreviate } from '../functions/abbreviate';
import isDev from '../functions/isDev';
import isTauri, { tauriObject } from '../functions/isTauri';
import { AutoMaximizerEffect } from '../synth/AutoMaximizerEffect';
import { ConvolutionReverbEffect } from '../synth/ConvolutionReverbEffect';
import { ExternalMidiSynth } from '../synth/ExternalMidiSynth';
import { FmSynth } from '../synth/FmSynth';
import { FourierSynth } from '../synth/FourierSynth';
import { GranularSampler } from '../synth/GranularSampler';
import { KarplusSynth } from '../synth/KarplusSynth';
import { KickSynth } from '../synth/KickSynth';
import { PatcheableSynth } from '../synth/PatcheableSynth';
import { PlaceholderSynth } from '../synth/PlaceholderSynth';
import { RingModEffect } from '../synth/RingModEffect';
import { Sampler } from '../synth/Sampler';
import { SimpleDelayEffect } from '../synth/SimpleDelayEffect';
import { SineCluster } from '../synth/SineCluster';
import { SineSynth } from '../synth/SineSynth';
import { AudioModule, ReceivesNotes } from '../synth/interfaces/AudioModule';
import { SynthParam, SynthParamStored, isValidParam } from '../synth/interfaces/SynthParam';
import { ThingyScoreFx } from '../synth/scoreEffects/Thingy';
import { PatcheableSynthVoice, Synth } from '../synth/super/Synth';
import { useAudioContextStore } from "./audioContextStore";
import { useAutomationLaneStore } from './automationLanesStore';
import { useExclusiveContentsStore } from './exclusiveContentsStore';
import { useLayerStore } from "./layerStore";
import { useMasterEffectsStore } from "./masterEffectsStore";

type AdmissibleSynthType = AudioModule | Synth | PatcheableSynthVoice;

/** storage for export/save, etc definitions */
type AudioModuleDefinition = {
    type: string;
    params: Array<SynthParamStored>;
}
type SynthChainDefinition = SynthChainStepDefinition[];
type SynthStackDefinition = SynthChainDefinition[];
export type SynthChainStepDefinition = AudioModuleDefinition | SynthStackDefinition;

export type SynthChannelsDefinition = SynthStackDefinition;

type SynthMinimalConstructor = new (audioContext: AudioContext, ...p: any) => (AdmissibleSynthType);

export class SynthConstructorWrapper {
    constructor(
        public audioContext: AudioContext,
        public constructorFunction: SynthMinimalConstructor,
        public extraParams: unknown[] = [],
        public name: string
    ) {
    }
    create = () => {
        const instance = new this.constructorFunction(this.audioContext, ...this.extraParams);
        instance.name = this.name;
        return instance;
    }
}

const titleCase = <T extends (string | undefined)>(str: T) => {
    if (!str) return str;
    return str.replace(
        /\w\S*/g,
        function (txt) {
            return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
        }
    );
}

const sampleNameToUName = <T extends (string | undefined)>(name?: T) => {
    if (!name) return name;
    return titleCase(
        camelCaseToUName(name)
            .replace(/[^a-zA-Z0-9]/g, " ").replace(/ +/g, " ")
    ).trim();
}

const camelCaseToUName = <T extends (string | undefined)>(name: T) => {
    if (!name) return name;
    return titleCase(name.replace(/([A-Z])/g, " $1")).trim();
}

const getSynthConstructors = (
    audioContext: AudioContext,
    includeExclusives: boolean,
): SynthConstructorWrapper[] => {
    let returnArray = [] as SynthConstructorWrapper[];

    // Sorry for the contortionist code.
    // I need a constructor that can be instanced at runtime
    // and know the name beforehand.
    // Before making better code I would need to make the sampler's sample 
    // chooseable after instantiation.

    const addAvailableSynth = <T extends any[]>(
        constr: SynthMinimalConstructor,
        name: string,
        extraParams?: T,
        isExclusive?: boolean,
        isOnlyLocal?: boolean,
    ) => {
        const epp = (extraParams || []) as T;
        if (isExclusive && !includeExclusives) return;
        if (isOnlyLocal && !isDev()) return;
        returnArray.push(
            new SynthConstructorWrapper(
                audioContext, constr, epp, name || camelCaseToUName(constr.name)
            )
        );
    }

    addAvailableSynth(PlaceholderSynth, 'PlaceholderSynth');

    sampleDefinitions.forEach((sampleDefinition) => {
        const ps = [
            sampleDefinition.samples,
            sampleDefinition.name,
            sampleDefinition.readme
        ];
        const sampleUname = sampleNameToUName(sampleDefinition.name);
        if (sampleDefinition.type === 'one shot') {
            addAvailableSynth(Sampler, sampleUname + " Sampler", ps, sampleDefinition.exclusive, sampleDefinition.onlyLocal);
        } else if (sampleDefinition.type === 'granular') {
            addAvailableSynth(GranularSampler, "Granular " + sampleUname, ps, sampleDefinition.exclusive, sampleDefinition.onlyLocal);
        } else {
            throw new Error("type not supported " + sampleDefinition.type)
        }

    });

    // impulseResponseSampleDefinitions.forEach(({
    //     name,
    //     path,
    //     collection,
    //     readme,
    // }) => {
    //     // When I create a sampler selector for bottom panel, I can pass the whole array so that 
    //     // the sample is chosen as param. Then I don't need to iterate over sampledefinitions
    //     const ps = [[
    //         { name, path, collection, readme }
    //     ]];
    //     addAvailableSynth(
    //         ConvolutionReverbEffect,
    //         ps, sampleNameToUName(name) + " Convolver", true, false
    //     );
    // });
    console.log("impulseResponseSampleDefinitions", impulseResponseSampleDefinitions);
    addAvailableSynth(
        ConvolutionReverbEffect,
        "Convolver", [impulseResponseSampleDefinitions], true, false
    );

    addAvailableSynth(KickSynth, 'KickSynth');
    addAvailableSynth(KarplusSynth, 'KarplusSynth');
    addAvailableSynth(SineCluster, 'SineCluster');
    addAvailableSynth(SineSynth, 'SineSynth');

    addAvailableSynth(SimpleDelayEffect, 'SimpleDelayEffect');
    addAvailableSynth(RingModEffect, 'RingModEffect');
    addAvailableSynth(AutoMaximizerEffect, 'AutoMaximizerEffect');

    addAvailableSynth(FourierSynth, "Fourier Synth", [], false, false);
    if (isDev()) {
        // bc. unfinished
        addAvailableSynth(FmSynth, "(xp) Fm Synth", [], false, true);
        addAvailableSynth(ThingyScoreFx, "(xp) Thingy Score Effect");
        addAvailableSynth(ExternalMidiSynth, "(xp) External  [],Midi Synth");

        addAvailableSynth(PatcheableSynth, "(xp) Dyna synth", [], false, true);
    }
    console.log("available channels", returnArray.map(s => s.name));

    return returnArray;
}

export const useSynthStore = defineStore("synthesizers", () => {
    const layerStore = useLayerStore();
    const exclusives = useExclusiveContentsStore();
    const audioContextStore = useAudioContextStore();
    const masterEffectsStore = useMasterEffectsStore();
    const automationStore = useAutomationLaneStore();
    const synthConstructorWrappers = ref<SynthConstructorWrapper[]>(getSynthConstructors(
        audioContextStore.audioContext,
        exclusives.enabled
    ));

    const channels = ref<SynthStack>(new SynthStack(audioContextStore.audioContext));
    const instancedSynths = ref<AdmissibleSynthType[]>([]);
    channels.value.output.connect(masterEffectsStore.myInput);

    const scheduleNote = (
        event: Note,
        eventStartAbsolute: number,
        eventDuration?: number,
    ) => {
        const synths = getLayerSynths(event.layer);
        if (!synths.length) return;
        const frequency = getFrequency(event);
        synths.forEach(synth => {
            if (synth instanceof PlaceholderSynth) return;
            if (eventDuration) {
                synth.scheduleStart(
                    frequency,
                    eventStartAbsolute,
                    event
                ).scheduleEnd(eventStartAbsolute + eventDuration);
            } else {
                synth.schedulePerc(
                    frequency,
                    eventStartAbsolute,
                    event
                );

            }
        })
    }
    const scheduleAutomation = (
        event: AutomationPoint,
        detinationTime: number,
        destinationParameter: SynthParam,
    ) => {
        if (!destinationParameter.animate) throw new Error("destination parameter is not animatable");
        destinationParameter.animate(event.value, detinationTime);
    }
    const releaseAll = () => channels.value.children.forEach((chain) => chain.releaseAll());
    const instanceAudioModule = (audioModule: SynthConstructorWrapper) => {
        const newModule = audioModule.create();
        console.log("adding audio module", newModule.name, "count", instancedSynths.value.length);
        instancedSynths.value.push(newModule);
        // to reduce traffic
        const enable = newModule.enable;
        if (enable) {
            if ('needsFetching' in newModule) {
                console.log("newModule needs fetching");
                if (exclusives.enabled) {
                    enable();
                } else {
                    setTimeout(() => {
                        enable();
                    }, 5000);
                }
            } else {
                enable();
            }
        }
        return newModule;
    }
    const findAudioModuleParamByName = (synth: AudioModule, name: string): SynthParam | undefined => {
        console.log("           finding param", name, "in", synth);
        const exact = synth.params.find((param) => {
            console.log("               param", param.displayName, param.displayName === name ? "==" : "!=", name);
            return param.displayName === name
        });
        if (exact) return exact;
        const similar = synth.params.find((param) => param.displayName?.includes(name));
        if (similar) return similar;
        const abbrevName = abbreviate(name, 5);
        const abbreviated = synth.params.find((param) => {
            if (!param.displayName) return false;
            return abbreviate(param.displayName, 5).includes(abbrevName)
        });
        return abbreviated;
    }
    const applyChainDefinition = (chain: SynthChain, definition: SynthChainDefinition, recycle = false) => {
        console.log("applying chain definition", definition);
        definition.forEach((chainStep: SynthChainStepDefinition, i) => {
            if (Array.isArray(chainStep)) {
                // it's a stack
                let stackInstance: SynthStack | undefined = undefined;
                if (recycle && chain.children[i] instanceof SynthStack) {
                    stackInstance = chain.children[i] as SynthStack;
                    console.log("recycling", stackInstance.name);
                }
                const stackDef: SynthStackDefinition = chainStep;
                if (!stackInstance) {
                    if (recycle) console.warn("recyclable stack not found in ", chain.children, "step", i, "described as", chainStep);
                    stackInstance = new SynthStack(audioContextStore.audioContext);
                    chain.addAudioModule(i, stackInstance);
                }
                applyStackDefinition(stackInstance, stackDef, recycle);
            } else {
                // It's an audio module
                let synth: AdmissibleSynthType | undefined = undefined;

                if (recycle && chain.children[i] && chain.children[i].name === chainStep.type) {
                    synth = chain.children[i] as AudioModule;
                    console.log("recycling", synth.name);
                }

                if (!synth) {
                    if (recycle) console.warn(
                        "recyclable synth not found in ", [...chain.children],
                        "step", i,
                        "described as", chainStep,
                        "not matching", chain.children[i]?.name, chainStep.type
                    );
                    let synthConstructor = synthConstructorWrappers.value.find((s) => s.name === chainStep.type);
                    if (!synthConstructor) {
                        const regex = new RegExp(chainStep.type.slice(0, 3));
                        const loosely = synthConstructorWrappers.value.find((s) => s.name.match(regex));
                        if (loosely) {
                            console.warn("synth named", chainStep.type, "not found, looking for similarly named: ", loosely?.name);
                            synthConstructor = loosely;
                        }
                    }
                    if (!synthConstructor) {
                        console.warn("synth not found", chainStep.type);
                        synthConstructor = synthConstructorWrappers.value[0];
                    }
                    synth = instanceAudioModule(synthConstructor);
                    chain.addAudioModule(i, synth);
                }

                const paramsDef = chainStep.params;

                if (synth instanceof AudioModule && paramsDef) {
                    for (let paramDef of paramsDef) {
                        const synthParam = findAudioModuleParamByName(synth, paramDef.displayName || "");
                        if (!synthParam) {
                            console.warn("param not found", paramDef.displayName);
                            continue;
                        }
                        synthParam.value = paramDef.value;
                    }
                }
            }
        });
    }

    const applyStackDefinition = (stack: SynthStack, definition: SynthStackDefinition, recycle = false) => {
        // TODO: replace foreach with for loop
        definition.forEach((chainDef: SynthChainDefinition, i) => {
            let chainInstance: SynthChain | undefined = undefined;
            if (recycle && stack.children[i] instanceof SynthChain) {
                chainInstance = stack.children[i] as SynthChain;
                console.log("recycling", chainInstance.name);
            }
            if (!chainInstance) {
                if (recycle) console.warn("recyclable chain not found in ", stack.children, "step", i, "described as", chainDef);
                chainInstance = stack.addChain();
            }
            applyChainDefinition(chainInstance, chainDef, recycle);
        });
    }

    const applyChannelsDefinition = (inChannels: SynthChannelsDefinition, recycle = false) => {
        console.group("applying channels definition", inChannels);
        if (recycle) {
            console.log("recycling synths");
        } else {
            channels.value.empty();
        }
        inChannels.forEach((chainDef, i) => {
            console.log("loading channel chain", chainDef);
            let chainInstance: SynthChain | undefined = undefined;
            if (recycle && channels.value.children[i] instanceof SynthChain) {
                chainInstance = channels.value.children[i] as SynthChain;
                console.log("recycling", chainInstance.name);
            }
            if (!chainInstance) {
                if (recycle) console.warn("recyclable chain not found in ", channels.value.children, "step", i, "described as", chainDef);
                chainInstance = channels.value.addChain();
            }
            applyChainDefinition(chainInstance, chainDef, recycle);
        });
        console.groupEnd();
    }

    const getDefinitionForAudioModule = (synth: AudioModule): AudioModuleDefinition => {
        let params = synth.params.filter((param: SynthParam) => {
            return param.exportable;
        }).map((param: SynthParam) => {
            const isAutomated = automationStore.isParameterAutomated(param);
            const ret = {
                value: isAutomated ? 0 : param.value,
            } as SynthParamStored
            if (param.displayName) {
                ret.displayName = param.displayName;
            }
            return ret;
        }) as SynthParamStored[]
        return {
            type: synth.name || "unknown",
            params
        }
    }

    const getDefinitionForChain = (fromChain: SynthChain): SynthChainDefinition => {
        return fromChain.children.map((step) => {
            if (step instanceof SynthStack) {
                return getDefinitionForStack(step);
            }
            if (step.patcheableType === PatcheableType.AudioModule) {
                const audioModule = step as AudioModule;
                return getDefinitionForAudioModule(audioModule);
            }
            console.error("no method to get definition for ", step);
            return [];
        })
    }

    const getDefinitionForStack = (stack: SynthStack): SynthStackDefinition => {
        return stack.children.map((chain) => {
            return getDefinitionForChain(chain);
        });
    }

    const getCurrentChannelsDefinition = (): SynthChannelsDefinition => {
        return getDefinitionForStack(channels.value);
    }

    const accessorStringToSynthParam = (accessorString?: string): SynthParam | undefined => {
        if (!accessorString) return undefined;
        const accessorParts = accessorString.split(".");
        type EitherAccessible = AudioModule | SynthChain | SynthStack | SynthParam | undefined;
        let recAccumulator = channels.value as EitherAccessible
        recursionLoop: for (let i = 0; i < accessorParts.length; i++) {
            const part = accessorParts[i];
            const partAsNumber = parseInt(part);
            switch (true) {
                case recAccumulator instanceof SynthChain: {
                    recAccumulator = (recAccumulator as SynthChain).children[partAsNumber] as SynthChain;
                    break;
                }
                case recAccumulator instanceof SynthStack: {
                    recAccumulator = (recAccumulator as SynthStack).children[partAsNumber] as SynthChain;
                    break;
                }
                case recAccumulator instanceof AudioModule || recAccumulator instanceof Synth: {
                    const audioModule = recAccumulator as AudioModule;
                    recAccumulator = findAudioModuleParamByName(audioModule, part);
                    break recursionLoop
                }
                default: {
                    console.error(
                        "could not find parameter accessed by ",
                        accessorString,
                        "at",
                        accessorParts.slice(0, i).join("."),
                        recAccumulator
                    );
                    recAccumulator = undefined;
                }
            }
            if (recAccumulator === undefined) {
                return undefined;
            }
        }
        if (isValidParam(recAccumulator)) {
            return recAccumulator;
        } else {
            console.error("Tried to get synth param, but access didn't lead to parameter, but this instead:", recAccumulator);
        }
    }


    /**
     * resolve assoc of
     * layer -> channels -> synth
     * falls back to default channel synth 0
     * 
     * could be memoized (it's called on every single trigger evt)
     */
    const getLayerSynths = (layerNo: number): ReceivesNotes[] => {
        const channelNo = layerStore.layers[layerNo]?.channelSlot as number | undefined;
        const channelIfExists = channels.value.children[channelNo || 0] as SynthChain | undefined;
        if (!channelIfExists) {
            return channels.value.children[0]?.getNoteReceivers() || [];
        }
        return channelIfExists.getNoteReceivers();
    }

    channels.value.addChain().name = "Default Channel";

    return {
        synthConstructorWrappers,
        instancedSynths,
        channels,
        getCurrentChannelsDefinition,
        scheduleNote,
        scheduleAutomation,
        releaseAll,
        getLayerSynths,
        applyChannelsDefinition,
        instanceAudioModule,
        accessorStringToSynthParam,
        testBeep: async () => {
            !isTauri() && console.warn("beep only works in tauri");
            const { invoke } = await tauriObject();
            await invoke("trigger", {
                frequency: 80 + 440 * Math.pow(2, Math.random()),
                amplitude: 1,
            });
            console.log("beeped");
        }

    }
});