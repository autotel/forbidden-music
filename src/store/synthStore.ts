
import { defineStore } from 'pinia';
import { ref } from 'vue';
import sampleDefinitions from "../_autogenerated_samples";
import { AutomationPoint } from '../dataTypes/AutomationPoint';
import { Note, getFrequency } from "../dataTypes/Note";
import isDev from '../functions/isDev';
import isTauri, { tauriObject } from '../functions/isTauri';
import { FmSynth } from '../synth/FmSynth';
import { FourierSynth } from '../synth/FourierSynth';
import { GranularSampler } from '../synth/GranularSampler';
import { KarplusSynth } from '../synth/KarplusSynth';
import { KickSynth } from '../synth/KickSynth';
import { PlaceholderSynth } from '../synth/PlaceholderSynth';
import { RingModEffect } from '../synth/RingModEffect';
import { Sampler } from '../synth/Sampler';
import { SineCluster } from '../synth/SineCluster';
import { SineSynth } from '../synth/SineSynth';
import { AudioEffect, AudioModule } from '../synth/interfaces/AudioModule';
import { SynthParam, SynthParamStored } from '../synth/interfaces/SynthParam';
import { Synth } from '../synth/super/Synth';
import { useAudioContextStore } from "./audioContextStore";
import { useExclusiveContentsStore } from './exclusiveContentsStore';
import { useLayerStore } from "./layerStore";
import { useMasterEffectsStore } from "./masterEffectsStore";
import { ConvolutionReverbEffect } from '../synth/ConvolutionReverbEffect';
import { AutoMaximizerEffect } from '../synth/AutoMaximizerEffect';

import impulseResponseSampleDefinitions from "../_autogenerated_impulse_responses";

type AdmissibleSynthType = AudioEffect | Synth | AudioModule;

export interface SynthChannel {
    chain: AdmissibleSynthType[];
    receivesNotes: Synth[]
}

type SynthMinimalConstructor = new (audioContext: AudioContext, ...p: any) => AdmissibleSynthType;

export type SynthChannelsDefinition = {
    chain: {
        type: string;
        params: Array<SynthParamStored>;
    }[]
}[]

export class SynthConstructorWrapper {
    constructor(
        public audioContext: AudioContext,
        public constructorFunction: SynthMinimalConstructor,
        public extraParams: unknown[] = [],
        public name: string
    ) {
    }
    create = () => {
        const instance = new this.constructorFunction(this.audioContext, ...this.extraParams);
        instance.name = this.name;
        return instance;
    }
}

const titleCase = <T extends (string | undefined)>(str: T) => {
    if (!str) return str;
    return str.replace(
        /\w\S*/g,
        function (txt) {
            return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
        }
    );
}

const sampleNameToUName = <T extends (string | undefined)>(name?: T) => {
    if (!name) return name;
    return titleCase(
        camelCaseToUName(name)
            .replace(/[^a-zA-Z0-9]/g, " ")
    );
}

const camelCaseToUName = <T extends (string | undefined)>(name: T) => {
    if (!name) return name;
    return titleCase(name.replace(/([A-Z])/g, " $1"));
}

const getSynthConstructors = (audioContext: AudioContext, includeExclusives: boolean): SynthConstructorWrapper[] => {
    let returnArray = [] as SynthConstructorWrapper[];

    // Sorry for the contortionist code.
    // I need a constructor that can be instanced at runtime
    // and know the name beforehand.
    // Before making better code I would need to make the sampler's sample 
    // chooseable after instantiation.

    const addAvailableSynth = <T extends any[]>(
        constr: SynthMinimalConstructor,
        extraParams?: T,
        name?: string,
        isExclusive?: boolean,
        isOnlyLocal?: boolean,
    ) => {
        const epp = (extraParams || []) as T;
        if (isExclusive && !includeExclusives) return;
        if (isOnlyLocal && !isDev()) return;
        returnArray.push(
            new SynthConstructorWrapper(
                audioContext, constr, epp, name || camelCaseToUName(constr.name)
            )
        );
    }

    addAvailableSynth(PlaceholderSynth);

    sampleDefinitions.forEach((sampleDefinition) => {
        const ps = [
            sampleDefinition.samples,
            sampleDefinition.name,
            sampleDefinition.readme
        ];
        const sampleUname = sampleNameToUName(sampleDefinition.name);
        if (sampleDefinition.type === 'one shot') {
            addAvailableSynth(Sampler, ps, sampleUname + " Sampler", sampleDefinition.exclusive, sampleDefinition.onlyLocal);
        } else if (sampleDefinition.type === 'granular') {
            addAvailableSynth(GranularSampler, ps, "Granular " + sampleUname, sampleDefinition.exclusive, sampleDefinition.onlyLocal);
        } else {
            throw new Error("type not supported " + sampleDefinition.type)
        }

    });

    impulseResponseSampleDefinitions.forEach(({
        name,
        path,
        collection,
        readme,
    } ) => {
        // When I create a sampler selector for bottom panel, I can pass the whole array so that 
        // the sample is chosen as param. Then I don't need to iterate over sampledefinitions
        const ps = [[
            { name, path, collection, readme }
        ]];
        addAvailableSynth(
            ConvolutionReverbEffect, 
            ps, sampleNameToUName(name) + " Convolver", true, false
        );
    });

    addAvailableSynth(KickSynth);
    addAvailableSynth(KarplusSynth);
    addAvailableSynth(SineCluster);
    addAvailableSynth(SineSynth);
    
    addAvailableSynth(RingModEffect);
    addAvailableSynth(AutoMaximizerEffect);

    if (isDev()) {
        // bc. unfinished
        addAvailableSynth(FmSynth, [], undefined, false, true);
        addAvailableSynth(FourierSynth, [], undefined, false, true);
        // addAvailableSynth(MIDIOutput);
        // notes sometimes stop before time, suspected poor use of timeouts
    }
    console.log("available channels", returnArray.map(s => s.name));

    return returnArray;
}

export const useSynthStore = defineStore("synthesizers", () => {
    const layerStore = useLayerStore();
    const exclusives = useExclusiveContentsStore();
    const audioContextStore = useAudioContextStore();
    const masterEffectsStore = useMasterEffectsStore();

    const synthConstructorWrappers = ref<SynthConstructorWrapper[]>(getSynthConstructors(
        audioContextStore.audioContext,
        exclusives.enabled
    ));

    const channels = ref<SynthChannel[]>([]);
    const instancedSynths = ref<AdmissibleSynthType[]>([]);

    const addChannel = () => {
        const newChannel = {
            chain: [],
            receivesNotes: [],
        };
        channels.value.push(newChannel);
        return newChannel;
    }


    const removeChannel = (index: number) => {
        channels.value.splice(index, 1);
    }

    addChannel();

    const scheduleNote = (
        event: Note,
        eventStartAbsolute: number,
        eventDuration?: number,
    ) => {
        const synths = getLayerSynths(event.layer);
        if (!synths.length) return;
        const frequency = getFrequency(event);
        synths.forEach(synth => {
            if (synth instanceof PlaceholderSynth) return;
            if (eventDuration) {
                synth.scheduleStart(
                    frequency,
                    eventStartAbsolute,
                    event
                ).scheduleEnd(eventStartAbsolute + eventDuration);
            } else {
                synth.schedulePerc(
                    frequency,
                    eventStartAbsolute,
                    event
                );

            }
        })
    }
    const scheduleAutomation = (
        event: AutomationPoint,
        detinationTime: number,
        destinationParameter: SynthParam,
    ) => {
        if (!destinationParameter.animate) throw new Error("destination parameter is not animatable");
        destinationParameter.animate(event.value, detinationTime);
    }
    const releaseAll = () => channels.value.forEach(({ chain }) => chain.forEach(audioModule => {
        if ('stop' in audioModule) {
            audioModule.stop()
        }
    }));
    const instanceAudioModule = (audioModule: SynthConstructorWrapper) => {
        const newModule = audioModule.create();
        console.log("adding audio module", newModule.name, "count", instancedSynths.value.length);
        // to reduce traffic
        if (newModule.needsFetching) {
            console.log("newModule needs fetching");
            if (exclusives.enabled) {
                newModule.enable();
            } else {
                setTimeout(() => {
                    newModule.enable();
                }, 5000);
            }
        } else {
            newModule.enable();
        }

        return newModule;
    }
    const rewireChain = (channel: SynthChannel) => {
        channel.receivesNotes = [];
        let prevModule: AdmissibleSynthType | undefined;

        for (let audioModule of channel.chain) {
            if ('receivesNotes' in audioModule) {
                channel.receivesNotes.push(audioModule);
            }
            if (audioModule.output) {
                audioModule.output.disconnect();
            }
            if (prevModule && prevModule.output && audioModule.input) {
                prevModule.output.connect(audioModule.input);
                console.log("connecting ", prevModule.name, "to", audioModule.name);
            }
            prevModule = audioModule;
        }

        if (prevModule && prevModule.output) {
            prevModule.output.connect(masterEffectsStore.myInput);
            console.log("connecting ", prevModule.name, "to effects store input");
        }
    }
    /**
     * enables, connects and in other ways notify
     * the change into a new synth
     */
    const addAudioModule = (targetChannel: SynthChannel, position: number, audioModule: SynthConstructorWrapper) => {
        const newModule = instanceAudioModule(audioModule);
        targetChannel.chain.splice(position, 0, newModule);
        rewireChain(targetChannel);
    }

    const replaceAudioModule = (
        targetChannel: SynthChannel,
        removedModule: AdmissibleSynthType,
        newModule: SynthConstructorWrapper
    ) => {
        const index = targetChannel.chain.indexOf(removedModule);
        if (index === -1) {
            console.warn("module not found in chain");
            return;
        }
        removedModule.disable();
        targetChannel.chain.splice(index, 1);
        const instancedModule = instanceAudioModule(newModule);
        targetChannel.chain.splice(index, 0, instancedModule);
        rewireChain(targetChannel);
    }

    const removeAudioModule = (targetChannel: SynthChannel, audioModule: AdmissibleSynthType) => {
        const index = targetChannel.chain.indexOf(audioModule);
        if (index === -1) {
            console.warn("module not found in chain");
            return;
        }
        audioModule.disable();
        targetChannel.chain.splice(index, 1);
        rewireChain(targetChannel);
    }

    const applyChannelsDefinition = (inChannels: SynthChannelsDefinition, addToCurrent = false) => {
        if (!addToCurrent) {
            channels.value = [];
        }
        inChannels.forEach(({ chain }) => {
            console.log("loading channel", chain);
            const newChannel = addChannel();
            chain.forEach((audioModule, i) => {
                let synth = synthConstructorWrappers.value.find((s) => s.name === audioModule.type);
                if (!synth) {
                    const regex = new RegExp(audioModule.type.slice(0, 3));
                    const loosely = synthConstructorWrappers.value.find((s) => s.name.match(regex));
                    if (loosely) {
                        console.warn("synth named", audioModule.type, "not found, looking for similarly named: ", loosely?.name);
                        synth = loosely;
                    }
                }
                if (!synth) {
                    console.warn("synth not found", audioModule.type);
                    synth = synthConstructorWrappers.value[0];
                }
                addAudioModule(newChannel, i ,synth);
            });
        });
    }

    const synthParamToAccessorString = (param?: SynthParam) => {
        if (!param) return undefined;
        if (typeof param === 'string') throw new Error("param is string");
        const synthWithParam = instancedSynths.value.find((synth) => synth.params.includes(param));
        if (!synthWithParam) throw new Error("synth with param not found");
        const synthName = synthWithParam.name;
        const paramName = param.displayName;
        return `${synthName}.${paramName}`;
    }

    const accessorStringToSynthParam = (accessorString?: string): SynthParam | undefined => {
        console.warn("accessor string to synth param, needs updating to target channel, represent multi-instance receivesNotes", accessorString);
        if (!accessorString) return undefined;
        const [synthName, paramName] = accessorString.split(".");
        const synth = instancedSynths.value.find((s) => s.name === synthName);
        if (!synth) {
            console.warn("synth named ", synthName, "not found", synthName);
            return undefined;
        }
        const param = synth.params.find((p) => p.displayName === paramName);
        if (!param) {
            console.warn("param not found", paramName);
            return undefined;
        }
        console.log("found automated param ", param);
        return param;
    }


    /**
     * resolve assoc of
     * layer -> channels -> synth
     * falls back to default channel synth 0
     */

    const getLayerSynths = (layerNo: number): Synth[] => {
        const channelNo = layerStore.layers[layerNo]?.channelSlot as number | undefined;
        const channelIfExists = channels.value[channelNo || 0] as SynthChannel | undefined;
        if (!channelIfExists) {
            return channels.value[0].receivesNotes;
        }
        return channelIfExists.receivesNotes;
    }

    return {
        synthConstructorWrappers,
        instancedSynths,
        channels,
        scheduleNote,
        scheduleAutomation,
        releaseAll,
        getLayerSynths,
        applyChannelsDefinition,
        removeChannel,
        addChannel,
        addAudioModule,
        removeAudioModule,
        replaceAudioModule,
        synthParamToAccessorString,
        accessorStringToSynthParam,
        testBeep: async () => {
            !isTauri() && console.warn("beep only works in tauri");
            const { invoke } = await tauriObject();
            await invoke("trigger", {
                frequency: 80 + 440 * Math.pow(2, Math.random()),
                amplitude: 1,
            });
            console.log("beeped");
        }

    }
});