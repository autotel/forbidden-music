
import { defineStore } from 'pinia';
import { ref } from 'vue';
import sampleDefinitions from "../_autogenerated_samples";
import { Note, getFrequency } from "../dataTypes/Note";
import { getDuration } from "../dataTypes/TimelineItem";
import isDev from '../functions/isDev';
import isTauri, { tauriObject } from '../functions/isTauri';
import { ClusterSineSynth } from '../synth/ClusterSineSynth';
import { GranularSampler } from '../synth/GranularSampler';
import { ComplexSampler } from '../synth/ComplexSampler';
import { ExternalMidiSynth } from '../synth/ExternalMidiSynth';
import { FmSynth } from '../synth/FmSynth';
import { FourierSynth } from '../synth/FourierSynth';
import { KarplusSynth } from '../synth/KarplusSynth';
import { KickSynth } from '../synth/KickSynth';
import { OneShotSampler } from '../synth/OneShotSampler';
import { SineSynth } from '../synth/SineSynth';
import { ExternalSynthInstance, OptionSynthParam, ParamType, SynthInstance, SynthParam } from "../synth/SynthInterface";
import { useAudioContextStore } from "./audioContextStore";
import { useEffectsStore } from "./effectsStore";
import { useExclusiveContentsStore } from './exclusiveContentsStore';
import { useLayerStore } from "./layerStore";
import { AutomationPoint } from '../dataTypes/AutomationPoint';
import { TraceType } from '../dataTypes/Trace';

type AdmissibleSynthType = SynthInstance | ExternalSynthInstance;

export interface SynthChannel {
    synth: AdmissibleSynthType;
    params: SynthParam[];
}

const createSynths = (audioContext: AudioContext, includeExclusives: boolean) => {

    const samplers = [] as (OneShotSampler | ComplexSampler)[];
    const exclusiveSamplers = [] as (OneShotSampler | ComplexSampler)[];
    const localOnlySamplers = [] as (OneShotSampler | ComplexSampler)[];
    let returnArray = [] as AdmissibleSynthType[];

    sampleDefinitions.forEach((sampleDefinition) => {
        const arrayWhereToPush = sampleDefinition.onlyLocal ? localOnlySamplers : (sampleDefinition.exclusive ? exclusiveSamplers : samplers);
        if (sampleDefinition.isComplexSampler) {
            arrayWhereToPush.push(new ComplexSampler(
                audioContext,
                sampleDefinition.samples,
                "(CPX)" + sampleDefinition.name,
                sampleDefinition.readme
            ))
        } else {
            arrayWhereToPush.push(new OneShotSampler(
                audioContext,
                sampleDefinition.samples,
                sampleDefinition.name,
                sampleDefinition.readme
            ))
        }
    });

    returnArray = [
        new SineSynth(audioContext),
        new ExternalMidiSynth(audioContext),
        ...samplers
    ];

    if (includeExclusives) {
        returnArray.push(...exclusiveSamplers);
        returnArray.unshift(new FourierSynth(audioContext));
        returnArray.unshift(new KickSynth(audioContext));
        returnArray.unshift(new ClusterSineSynth(audioContext));
    } else {
        console.log("exclusives disabled");
    }
    returnArray.push(new KarplusSynth(audioContext));

    if (isDev()) {
        // bc. unfinished
        returnArray.push(new FmSynth(audioContext));
        returnArray.push(new GranularSampler(
            audioContext, sampleDefinitions[0].samples[2],
            "Test Granular Sampler", sampleDefinitions[0].readme
        ));
        // bc. pirate
        returnArray.push(...localOnlySamplers);
    } else {
        console.log("local only samples disabled");
    }
    console.log("available channels", returnArray.map(s => s.name));
    return returnArray;
}

export const useSynthStore = defineStore("synthesizers", () => {
    const layerStore = useLayerStore();
    const exclusives = useExclusiveContentsStore();
    const audioContextStore = useAudioContextStore();
    const effectsStore = useEffectsStore();

    const availableSynths = ref(
        createSynths(audioContextStore.audioContext, exclusives.enabled) as AdmissibleSynthType[]
    );
    const channels = ref<SynthChannel[]>([]);

    const addChannel = (index?: number) => {
        const newChannel = {
            synth: availableSynths.value[0],
            params: availableSynths.value[0].params,
            layer: 0
        };
        if (index !== undefined) {
            channels.value[index] = newChannel;
            return newChannel;
        } else {
            channels.value.push(newChannel);
        }
        return newChannel;
    }


    const removeChannel = (index: number) => {
        channels.value.splice(index, 1);
    }

    const getOrCreateChannel = (index: number) => {
        if (!channels.value[index]) {
            addChannel(index);
        }
        return channels.value[index];
    }

    getOrCreateChannel(0);

    const scheduleNote = (
        event: Note,
        eventStartAbsolute: number,
        eventDuration?: number,
    ) => {
        const synth = getLayerSynth(event.layer);
        if (!synth) return;
        const frequency = getFrequency(event);
        if (eventDuration) {
            synth.triggerAttackRelease(
                frequency,
                eventDuration,
                eventStartAbsolute,
                event.velocity
            );
        } else {
            synth.triggerPerc(
                frequency,
                eventStartAbsolute,
                event.velocity
            );

        }
    }
    const scheduleAutomation = (
        event: AutomationPoint,
        detinationTime: number,
        destinationParameter: SynthParam,
    ) => {
        if (!destinationParameter.animate) throw new Error("destination parameter is not animatable");
        destinationParameter.animate(event.value, detinationTime);
    }
    const releaseAll = () => channels.value.forEach(({ synth }) => synth.releaseAll());
    /**
     * enables, connects and in other ways notify
     * the change into a new synth
     */
    const setSynth = (synth: AdmissibleSynthType, channel = 0) => {
        const targetChannel = getOrCreateChannel(channel);

        const oldSynth = targetChannel.synth;
        console.log("channel", channel, "disabling old synth", oldSynth.name, "enabling", synth.name);
        if ('outputNode' in oldSynth) {
            // TODO: doing this can cause a synth that is needed to get disconnected
            // in a multi timbral situation
            // oldSynth.outputNode.disconnect();
            console.log("disconnecting ", oldSynth.name, "from effects store input");
        }
        oldSynth.disable();

        targetChannel.synth = synth;
        targetChannel.params = synth.params;

        Object.assign(targetChannel, {
            synth: synth,
            params: synth.params,
        })

        synth.enable();
        if ('outputNode' in synth) {
            synth.outputNode.connect(effectsStore.myInput);
            console.log("connecting ", synth.name, "to effects store input");
        }
    }

    const setSynthByName = (synthName: string, channel = 0) => new Promise<AdmissibleSynthType>((resolve, reject) => {
        console.log("set synth by name", synthName);
        audioContextStore.audioContextPromise.then(() => {
            const foundSynth = availableSynths.value.find((s) => s.name === synthName);
            if (foundSynth) {
                setSynth(foundSynth, channel);
                resolve(foundSynth);
            } else {
                console.error("synth not found", synthName);
                console.log("available synths", availableSynths.value.map(s => s.name));
                reject();
            }
        });
    })


    const synthSelector = (synthChannel: SynthChannel): OptionSynthParam => ({
        type: ParamType.option,
        displayName: "Synth",
        getValue(synthChannel: SynthChannel) {
            const ret = synthChannel.synth ? availableSynths.value.indexOf(
                synthChannel.synth
            ) : 0;
            if (ret === -1) {
                console.error("synth not found");
                return 0;
            }
            return ret;
        },
        setValue(synthChannel: SynthChannel, choiceNo: number) {
            if (!availableSynths.value[choiceNo]) throw new Error(`no synth at index ${choiceNo}`);
            setSynth(availableSynths.value[choiceNo], channels.value.indexOf(synthChannel));
        },
        get value() {
            return this.getValue(synthChannel);
        },
        set value(choiceNo: number) {
            this.setValue(synthChannel, choiceNo);
        },
        options: availableSynths.value.map((s, index) => ({
            value: index,
            displayName: s.name,
        })),
        exportable: true,
    })

    const synthParamToAccessorString = (param?: SynthParam) => {
        if (!param) return undefined;
        if (typeof param === 'string') throw new Error("param is string");
        const synthWithParam = availableSynths.value.find((synth) => synth.params.includes(param));
        if (!synthWithParam) throw new Error("synth with param not found");
        const synthName = synthWithParam.name;
        const paramName = param.displayName;
        return `${synthName}.${paramName}`;
    }

    const accessorStringToSynthParam = (accessorString?: string) => {
        console.log("accessor string to synth param", accessorString);
        if (!accessorString) return undefined;
        const [synthName, paramName] = accessorString.split(".");
        const synth = availableSynths.value.find((s) => s.name === synthName);
        if (!synth) {
            console.warn("synth not found", synthName);
            return undefined;
        }
        const param = synth.params.find((p) => p.displayName === paramName);
        if (!param) {
            console.warn("param not found", paramName);
            return undefined;
        }
        console.log("found automated param ", param);
        return param;
    }

    /**
     * resolve assoc of
     * layer -> channels -> synth
     * falls back to default channel synth 0
     */

    const getLayerSynth = (layerNo: number): AdmissibleSynthType | undefined => {
        const channelNo = layerStore.layers[layerNo]?.channelSlot as number | undefined;
        const channelIfExists = channels.value[channelNo || 0] as SynthChannel | undefined;
        if (!channelIfExists) {
            return channels.value[0].synth;
        }
        return channelIfExists.synth;
    }

    return {
        availableSynths,
        channels,
        scheduleNote,
        scheduleAutomation,
        releaseAll,
        setSynthByName,
        getOrCreateChannel,
        synthSelector,
        getLayerSynth,
        removeChannel,
        addChannel,
        synthParamToAccessorString,
        accessorStringToSynthParam,
        testBeep: async () => {
            !isTauri() && console.warn("beep only works in tauri");
            const { invoke } = await tauriObject();
            await invoke("trigger", {
                frequency: 80 + 440 * Math.pow(2, Math.random()),
                amplitude: 1,
            });
            console.log("beeped");
        }

    }
});