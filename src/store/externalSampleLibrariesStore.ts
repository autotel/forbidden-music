import factorySampleKits from "@/_autogenerated_samples";
import { assertSampleKitDefinition, SampleKitDefinition } from "@/dataTypes/SampleKitDefinition";
import { assertSampleLibraryDefinition, SamplesLibraryDefinition } from "@/dataTypes/SampleLibraryDefinition";
import { tauriObject } from "@/functions/isTauri";
import { FileEntry } from "@tauri-apps/api/fs";
import { defineStore } from "pinia";
import { computed, ref } from "vue";

export const libPathIsRemote = (libPath: string) => {
    return !(libPath.startsWith('file://') || libPath.startsWith('/'));
}

const recursiveFileSearch = async <T>(
    dir: string,
    foundCallback: (path: string) => T,
    depthLeft: number = 5,
) => {
    const { fs } = await tauriObject();
    const results: T[] = [];
    try {
        const entries: FileEntry[] = await fs.readDir(dir);
        for (const entry of entries) {
            if (entry.children) {
                if (depthLeft > 0) {
                    const subResults = await recursiveFileSearch(
                        entry.path, foundCallback, depthLeft - 1
                    );
                    results.push(...subResults);
                } else {
                    console.warn("Max depth reached in", dir);
                }
            } else {
                const found = await foundCallback(entry.path);
                if (found) {
                    results.push(found);
                }
            }
        }
    } catch (e) {
        console.error('Error reading dir', dir, e);
    }
    return results;
}

const getLibrariesFrom = async (path: string, accumulator: {
    libraries: SamplesLibraryDefinition[],
    kits: SampleKitDefinition[],
}) => {
    const isNamingsFilename = path.endsWith('namings.json');
    const isSamplesKitFilename = path.endsWith('samplesKit.json');
    const isSamplesLibraryFilename = path.endsWith('samplesLibrary.json');
    if (isNamingsFilename) {
        return false; // not implemented
    } else if (isSamplesKitFilename) {
        const kit = await loadAndParseSamplesKitFile(path);
        if (kit) {
            accumulator.kits.push(kit);
        }
    } else if (isSamplesLibraryFilename) {
        const lib = await loadAndParseSamplesLibraryFile(path);
        if (lib) {
            accumulator.libraries.push(lib);
        }
    }
}

const loadAndParseNamingsFile = async (path: string): Promise<SampleKitDefinition | false> => {
    console.warn('Namings dynamic loading not implemented', path);
    return false;
    const { fs } = await tauriObject();
    const fileContent = await fs.readTextFile(path);
    const parsed = JSON.parse(fileContent);
}

const loadAndParseSamplesKitFile = async (path: string): Promise<SampleKitDefinition | false> => {
    try {
        const { fs } = await tauriObject();
        const fileContent = await fs.readTextFile(path);
        const parsed = JSON.parse(fileContent);
        const asserted = assertSampleKitDefinition(parsed);
        return asserted;
    } catch (e) {
        console.error('Error parsing samples file', path, e);
        return false;
    }
}

const loadAndParseSamplesLibraryFile = async (libDefPath: string): Promise<SamplesLibraryDefinition | false> => {
    try {
        const { fs, path } = await tauriObject();
        const fileContent = await fs.readTextFile(libDefPath);
        const parsed = JSON.parse(fileContent);
        const asserted = assertSampleLibraryDefinition({
            ...parsed,
            url: await path.resolve(libDefPath),
        });
        // libDefPath points to the json file, we need the folder
        const pathBase = await path.resolve(libDefPath, '../');
        for(const kit of asserted.content) {
            
            for (const sample of kit.samples) {
                sample.path = await path.resolve(pathBase, sample.path);
            };
        }
        return asserted;
    } catch (e) {
        console.error('Error parsing samples file', libDefPath, e);
        return false;
    }
}

const listLocalSampleKits = async () => {
    const result = {
        libraries: [] as SamplesLibraryDefinition[],
        kits: [] as SampleKitDefinition[],
    };
    const userSampĺesDirs = [
        // './',
        './user sound libs',
        // await path.resourceDir(),
        // await path.appDataDir(),
        // await path.appConfigDir(),
        // await path.audioDir(),
        // await path.executableDir(),
        // await path.appCacheDir(),
        // await path.documentDir(),
        // '/home/joaquin',
    ];
    for (const dir of userSampĺesDirs) {
        try {
            await recursiveFileSearch(dir, async (path) => {
                await getLibrariesFrom(path, result);
            });
        } catch (e) {
            console.log("cannot access", dir, e);
        }
    }
    console.log('local samples found:', result);
    return result;
}

export default defineStore('externalSampleLibrariesStore', () => {
    const listOfExternalLibs = ref([{
        url: 'localhost',
        name: 'factory',
        error: '',
        content: factorySampleKits
    }] as SamplesLibraryDefinition[]);

    const listOfAvailableSampleKits = computed(() => {
        return [...listOfExternalLibs.value.flatMap(lib => lib.content)];
    });


    const addLibraryUrl = async (definitionUrl: string) => {
        console.log("add library", definitionUrl);
        let error = '';
        try {
            const newDef = await fetch(definitionUrl).then(res => res.json());
            const checkedList = assertSampleLibraryDefinition(newDef);
            listOfExternalLibs.value.push({
                ...checkedList,
                url: definitionUrl,
                error,
            });
        } catch (e) {
            listOfExternalLibs.value.push({
                url: definitionUrl,
                name: '',
                error: e + '',
                content: [],
            });
        }
    }

    const removeLibraryUrl = (definitionUrl: string) => {
        listOfExternalLibs.value = listOfExternalLibs.value.filter(({ url }) => url !== definitionUrl);
    }

    addLibraryUrl('http://127.0.0.1:3010/samplesLibrary.json');
    // addLibraryUrl('http://autotel-forbidden-music.atwebpages.com/samples.json');

    (async () => {
        const { kits, libraries } = await listLocalSampleKits();
        listOfExternalLibs.value.push(...libraries);
        listOfExternalLibs.value.push({
            url: 'local',
            name: 'user',
            content: kits,
        });
    })();

    return {
        listOfExternalLibs,
        listOfAvailableSampleKits,
        addLibraryUrl, removeLibraryUrl
    }
});